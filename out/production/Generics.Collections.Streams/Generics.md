Что такое generic и какую проблему они решают
-
Параметризованные типы — дженерики - особые средства языка Java для реализации обобщенного программирования: 
особого подхода к описанию данных и алгоритмов, позволяющего работать с различными типами данных без изменения 
их описания.
Реализуем общую библиотечную логику, которая мб применена к объектам разных типов. Как сделать так, чтобы для поддержки 
нового типа, не приходилось копировать весь алгоритм и заменять там одно имя типа на другое?
В 5 версии языка добавили возможность параметризации классов, интерфейсов и методов каким-то типом. 
Т.е. вместо конкретного типа можно объявить и затем использовать некоторую переменную, а качестве качестве которой 
может быть подставлен любой тип, удовлетворяющий условиям.
  
Ограничения дженериков в java:
- Параметризация возможна только ссылочным типом.
- Внутри параметризованного класса или метода нельзя создавать экземпляр или массив T, также не работает проверка
`instanceof()`, так как внутри класса про конкретное T, с котором создали данный экземпляр ничего неизвестно. 
  А приведение типа к T, хоть и скомпилируется, но ничего не сделает( не проверит, что объект действительно 
  является экземпляром T). 
  Это позволяет реализовать трюк по превращению проверяемого исключения в непроверяемое:
  
       import  java.io.IOException;
  
        public  class  Hack {
             public  static  void  main(String [] args) {
  
                throwAsUnchecked(new  IOException ());
            }
  
            private  static  void  throwAsUnchecked(Exception e) {
  
                Hack.<RuntimeException >genericThrow(e);
            }
  
            private  static  <T extends  Throwable >void  genericThrow(Exception e) throws T { 

              throw (T) e;
               }
        }
    Т.к. исключения делятся на проверяемые и не проверяемые только с точки зрения компилятора.\
    Для JVM все исключения непроверяемые. Пользоваться им не нужно.

   Зачем нужен Optional
- Встречая в программе переменную ссылочного типа, мы не можем определить допускает ли логика программы значение null. 
  Надо ли делать на нее проверку — источник большого кол-ва проблем. Как вариант решения — аннотация @NonNull. 
  Они не входят в стандартную библиотеку, поэтому компилятор не может их использовать для проверки корректности кода.
   Optional решают данную проблему на уровне системы типов. Обычная ссылка и потенциально отсутствующая ссылка 
  становятся разными типами, несовместимыми друг с другом. Т.е. более строгая проверка типов во время компиляции
- Устранение необходимости явного приведения типов
- Обертка в виде Optional позволяет писать код без if-ов.
   ***  
    
Как объявляется параметризованный класс?
- После имени класса идут угловые скобки с именами дженерик-параметров.
`public final class Optional <T>`
-  Ограничения на тип параметра:
   `public final class Optional <T extends имя класса, интерфейса...>`
- Что можно подставлять в качестве значения параметра X при использовании этого класса в программе?
    
        public class Example<X> {
         ...
        }
  * имя любого класса (например, Object);
  * значение X можно не указывать, т.е. использовать класс Example как обычный непараметризованный;
  * символ "?" или более сложное выражение с ключевыми словами extends и super;
  * имя любого перечисления (например, DayOfWeek);
  * имя любого интерфейса (например, CharSequence);

  
Как работать с ним в программе? 
- Возвращает пустой Optional: `Optional<String> foo = Optional.empry();`
- Возвращает Optional, содержащий указанный объект: `Optional<String> bar = Optional.of("bar");`
- Возвращает Optional, содержащий указанный объъкт, если там не `null`, а если там `null`, то возвращается пустой 
  Optional  : `Optional<String> baz = Optional.ofNullable("buz");`  
  
  Компилятор видит значение какого типа мы передаем и отдает нам значение Optional параметризованное этим типом. 
- Если мы хотим получить из строки optional параметризованный CharSequence, то надо явно указать на это компилятору: 
  `Optional<CharSequence> optionalCharSequence = Optional.<CharSequence>jfNullable("baz");`
- Если бы конструктор optional бфл публичным, то экземпляр можно было бы создать так:
  `Optional<String> newOptional = new Optional <>("foobar");`   
  `<>` - dimond operator, компилятор сам подставит параметры, взятые из типа переменной, куда мы присваиваем значения.
  Работает только вместе с `new`. 
  
  
В Java класс Optianl всегда один, с какими бы параметрами его не инстанцировали. Компилятор не создает 
специализированную версию класса, а создает единственную максимально общую версию класса и в байт-коде получается класс,
где вместо Т подставлен тип Object. Из-за того, что класс один, компилятор колдует с различными параметризациями. 

  
Поведение дженериков совместно с наследованием
  
`Optional<Integer>` нельзя присвоить в `Optional<Number>`. С точки зрения компилятора эти типы не совместимы. 
Это запрещено потому что: если в Optional есть метод set(), который заменяет объект внутри контейнера. 
Тогда присвоив `Optional<Integer>` в `Optional<Number>` мы могли бы после заменить `Optional<Integer>` на
другой тип, тем самым нарушив ограничения при создании контейнера. Общий родитель Object.
  

        Number  number = new  Integer (1);

        Number []  numberArray = new  Integer [10];


        Optional <Integer > optionalInt = Optional.of(1);

        Optional <Number > optionalNumber = optionalInt;

        optionalNumber.set(new  BigDecimal("3.14"));





