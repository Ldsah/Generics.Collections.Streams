Коллекции
-
Зачем нужны коллекции?   

Коллекции - разнообразные контейнеры однотипных элементов.  
Динамический размер.  
Защита от изменений, так как могут разрешать чтение, но запрещать изменения содержимого.  
Есть много удобных и полезных методов.  
Есть специализированные коллекции для многопоточного использования. Много потоков могут работать с одним и тем же
набором объектов, не ломая его.   

Классы коллекций являются дженериками и параметризуются типом хранимых внутри элементов. 
Если нужно хранить примитивы, то примитивные значения можно превратить в объекты при помощи классов-оберток. 
Или можно написать класс, похожий на коллекцию, но хранящий внутри примитивы. Можно позаимствовать такой класс из 
сторонней библиотеки.  
Есть метод итератор, который позволяет обходить коллекции. Удалять элементы коллекции надо через итератор, другой способ
обхода бросит exeption.   
  
Разновидности коллекций  
* List<E> - простой список элементов, проиндексированный от 0 до n-1. Доступ к элементам по их индексам. Один и тот
же элемент может встречаться в списке несколько раз. equals() сравнивает списки по-содержимому.  
Общеупотребительные реализации List<E>:  
1. ArrayList<>();, реализует лист поверх массива. Дает дешевый доступ к элементу по индексу, добавление или удаление уже 
не такое дешевое, так как может приводить к передобавлению, сдвигам в массиве. 
1. LinkedList<>();, основано на двусвязном списке. Позволяет эффективно удалять и добавлять элементы в конце списка, 
так как не надо перемещать большие куски памяти, перевыделять массивы. Зато доступ по индексу дороже, так как требуется
 сделать n-прыжков по указателям от начала списка.  
   При объявлении переменной лучше пользовать максимально общим интерфейсом, а конкретный класс указывать вместе 
   с созданием экземпляра.  
   `List<Integer> list1 = new ArrayList<>();`

* Queue<E> - очередь - стандартная структура данных, обеспечивающая порядок FIFO(first in, first out).
Элементы в очередь добавляются с хвоста и извлекаются из головы очереди.  
Наследник: Deque<E> - отличается от очереди тем, что может добавлять и удалять элементы как в хвосте, так и в голове.  
Реализации интерфейса Deque<E>:
1.ArrayDeque<>(); Deque поверх массива.
LinkedList<>();
  

* Set<E> - множество, обеспечивает уникальность содержащихся в ней элементов. При попытке добавить дубликат, множество 
изменено не будет. Не добавляет новых методов относительно интерфейсов collection, а только уточняет семантику 
  существующих. Например, equals() сравнивает 2 множества по-содержимому.  
  Реализаций интерфейса Set<> несколько: 
  - HashSet<> - реализация мнодества на основе хэш-таблицы. Важную роль тут играет метод hashCode(). 
    Использует hashCode обекта для определения места в ячейке таблицы, куда нужно положить этот объект. Важно 
    согласовать реализацию equals() и hashCode()^
      
        a.equals(b) => a.hashCode() == b.hashCode();
    Если это соотношение нарушается, то hashSet() будет работать с элементами неправильно: добавлять элементы, но не 
    находить это, или один и тот же элемент добавится много раз в разные ячейки. Объект не должен меняться пока он лежит
    в Hash-таблице(не должны меняться его поля, влияющие на вычесления hashCode() и equals())
  - Если порядок элементов важен, то предлагается использовать другую реализацию LinkedHashSet<>();
Отличается тем, что провязывает элементы в список в порядке их добавления.
  - От Set<> наследуется интерфейс SortedSet<> - упорядоченное множество. Обеспечивает обход итератором элементов в 
  порядке возрастания.  Имеет свои дополнительные методы.   
  - Реализация интерфейса SortedSet<> - TreeSet<> - внутри него самобалансирующаяся двочиное дерево поиска(красно-черное). 
Чтобы сравнивать элементы друг с другом, элементы должны наследовать интерфейс java.lang.Comparable<T> с методом 
  compareTo(T). Либо в конструктор TreeSet() должен передаваться экземпляр j.u.Comparator<T> с методом Compare(T, T). 
        

* Map<K, V> - отображение или ассоциативный массив. не наследует интерфейс Collection, но идеологически относится к
коллекциям. В отличие от массивов, где элементы индексируются числами, он позволяет индексировать элементы
  произвольными объектами(строками, комплексными числами и т.д.). 
  
  
В работе с коллекциями помогает утилитный класс java.util.Collections, в котором есть методы для перетасовывания списка
или сортировки списка.  

Вопросительный знак говорит компилятору: коллекция чем-то параметризована, но в данном месте кода мы не знаем, 
чем именно. Чтобы не дать нам случайно нарушить параметризацию коллекции, т.е. добавить в нее объект
неправильного класса, компилятор не разрешает ничего добавлять: 
`Collection<?> collection = ...;
Object object = ...;`



