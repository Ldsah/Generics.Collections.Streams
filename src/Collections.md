Коллекции
-
Зачем нужны коллекции?   

Коллекции - разнообразные контейнеры однотипных элементов.  
Динамический размер.  
Защита от изменений, так как могут разрешать чтение, но запрещать изменения содержимого.  
Есть много удобных и полезных методов.  
Есть специализированные коллекции для многопоточного использования. Много потоков могут работать с одним и тем же
набором объектов, не ломая его.   

Классы коллекций являются дженериками и параметризуются типом хранимых внутри элементов. 
Если нужно хранить примитивы, то примитивные значения можно превратить в объекты при помощи классов-оберток. 
Или можно написать класс, похожий на коллекцию, но хранящий внутри примитивы. Можно позаимствовать такой класс из 
сторонней библиотеки.  
Есть метод итератор, который позволяет обходить коллекции. Удалять элементы коллекции надо через итератор, другой способ
обхода бросит exeption.  
  
Разновидности коллекций  
* Set<E> - множество, обеспечивает уникальность содержащихся в ней элементов. При попытке добавить дубликат, множество 
изменено не будет. Не добавляет новых методов относительно интерфейсов collection, а только уточняет семантику 
  существующих. Например, equals() сравнивает 2 множества по-содержимому.  
  Реализаций интерфейса Set<> несколько: 
  - HashSet<> - реализация мнодества на основе хэш-таблицы. Важную роль тут играет метод hashCode(). 
    Использует hashCode обекта для определения места в ячейке таблицы, куда нужно положить этот объект. Важно 
    согласовать реализацию equals() и hashCode()^
      
        a.equals(b) => a.hashCode() == b.hashCode();
    Если это соотношение нарушается, то hashSet() будет работать с элементами неправильно: добавлять элементы, но не 
    находить это, или один и тот же элемент добавится много раз в разные ячейки. Объект не должен меняться пока он лежит
    в Hash-таблице(не должны меняться его поля, влияющие на вычесления hashCode() и equals())
  - Если порядок элементов важен, то предлагается использовать другую реализацию LinkedHashSet<>();
Отличается тем, что провязывает элементы в список в порядке их добавления.
  - От Set<> наследуется интерфейс SortedSet<> - упорядоченное множество. Обеспечивает обход итератором элементов в 
  порядке возрастания.  Имеет свои дополнительные методы.   
  - Реализация интерфейса SortedSet<> - TreeSet<> - внутри него самобалансирующаяся двочиное дерево поиска(красно-черное). 
Чтобы сравнивать элементы друг с другом, элементы должны наследовать интерфейс java.lang.Comparable<T> с методом 
  compareTo(T). Либо в конструктор TreeSet() должен передаваться экземпляр j.u.Comparator<T> с методом Compare(T, T). 
      
* Map<K, V> - отображение или ассоциативный массив. не наследует интерфейс Collection, но идеологически относится к
коллекциям. В отличие от массивов, где элементы индексируются числами, он позволяет индексировать элементы
  произвольными объектами(строками, комплексными числами и т.д.). 
  
  
В работе с коллекциями помогает утилитный класс java.util.Collections, в котором есть методы для перетасовывания списка
или сортировки списка. 
  
  



