Документация метода Objects.hash()
---

Генерирует хэш-код для последовательности введенных значений. 
Хэш код генерируется как если бы введенные значения были помещены в массив, и массив был хэширован через вызов
метода Arrays.hashCode(Object[]).
Этот метод полезен для реализации Object.hashCode() на объектах содержащих несколько полей. 
Например, если объект имеет три поля: x, y, и z, можно было бы написать:  

    @Override public int hashCode() {
    return Objects.hash(x, y, z);
  

Хэш функции
---

Хэш функция это любая функция, которая может быть использована для сопоставления данных произвольного размера
со значениями фиксированной длины. Значения возвращаемые через хэш-функцию называются хэш значениями, хэш кодами,
дайджестами, или просто хэшами. Значения обычно используются для индексирования таблицы фиксированного размера, 
называемой хэш таблицей. Использование хэш функции для индексирования хэш таблицы называется хэширование или 
адресация распределенного хранилища.  
Хэш функции и связанные с ними хэш таблицы используются в приложениях для хранения и извлечения данных, для доступа к 
данным за короткое или почти постоянное время для извлечения, и требуют некоторое пространство хранилища только 
незначительно превышающее общее пространство требуемое для хранения данных или их записей. 
Хэширование это эффективная с точки зрения вычеслений и пространства для хранения форма доступа к данным, которая 
предотвращает нелинейного времени доступа к упорядоченным и неупорядоченным спискам и структурированным деревьям, и
часто экспоненциальных требований к хранению прямого доступа к большим постоянным пространствам(state spaces of large?)
или к ключам переменной длины.  
Использование хэш-функций основывается на взаимодействии статических свойств ключа и функции: худший случай поведения 
это невыносимо плохой с ничтожно маленькой вероятностью/????? и средний случай поведения может быть близок к оптимальному
(минимальные коллизии).(Use of hash functions relies on statistical properties of key and function interaction:
worst case behavior is intolerably bad with a vanishingly small probability, and average case behavior can be
nearly optimal (minimal collisions).)  
Хэш-функции (и частные конфузы) зависят от контрольных сумм, контрольных чисел, отпечатков пальцев, сжатия с потерями, 
функций рандомизации, кодов, исправляющих ошибки, и шифров. Хотя эти концепции в некоторой степени пересекаются, каждая 
из них имеет свои собственные цели и требования, а также разработана и оптимизирована по-разному. Хэш-функции отличаются
от концепций, пронумерованных в основном с точки зрения целостности данных.  

####Обзор

Хэш функция принимается на ввод как ключ, который связан с информацией или записью и используется для их идентификации 
в приложении, хранящем данные и извлекающем их. Ключи могут быть фиксированной длины, как целое число, или переменной
длины, как имя. В некоторых случаях ключ это сама информация. Выходные данные представляют собой хэш код, 
используемы для индексации хэш-таблицы, содержащий данные, или записи, или ссылки на них.  
Хэш функции могут выполнять три функции: 
1. Конвертируйте переменную длину ключей в значение фиксированной длины(обычно длина машинного слова или меньше) , 
   складывая их по словам или другим единицам с помощью оператора сохранения четности, такого как ADD или XOR.
1. Закодируйте биты ключа так, что результирующие значения были равномерно распределены по пространству ключей.
1. Сопоставьте значения ключей в единицы, меньшие или равные размеру таблицы.  
Хорошая хэш функция удовлетворяет двум базовым свойствам:
   1. Она должна быстро вычисляться;
   1. Она должна минимизировать повторение выходящее значение(коллизия). Хэш функции основываются нна генерировании 
    благоприятных вероятностей для их эффективности, сокращение времени доступа до почти константного. Высокие 
    коэффициенты загрузки таблиц, патологические наборы ключей и плохо разработанные хэш-функции могут привести 
    к тому, что время доступа приблизится к линейному числу элементов в таблице. Хэш функции могут быть разработаны 
    таким образом, что обеспечить наилучшую производительность в худшем случае, хорошая производительность при высоких 
      коэффициентах загрузки таблиц, и в специальных случаях, идеальное отображение ключей в хэш кодах. 
      Реализация основывается на (parity-preserving bit operations) битовых операциях, умножении или делении. 
      Необходимое дополнение для хэш функций это метод разрешения коллизий, который использует вспомогательную структуру
      данных такую как linked lists, или систематическое исследование таблиц для поиска пустых слотов.

####Хэш таблицы

Хэш функции используются совместно с хэш таблицей для хранения и извлечения данных или записей данных.
Хэш функция переводит ключ связанный с каждым датумом или записью в хэш код, который используется как индекс в хэш таблице.
Когда элемент должен быть добавлен в таблицу, хэш код может индексировать пустой слот(также называемый ведром),
в этом случае элемент должен быть добавлен в данное место таблицы. Если хэш код индексирует заполненный слот, требуется
какое-либо разрешение коллизии: новый элемент может быть пропущен(не добавлен в таблицу), или может заменить элемент в 
таблицу, или он может быть добавлен в таблицу с помощью определенной процедуры в несколько другой слот. 
Эта процедура зависит от структуры хэш таблицы: при цепном хэшировании каждый слот является главой linked list или 
цепочки, и элементы, которые сталкиваются в слоте, будут добавлены в цепь. Цепочки могут храниться в случайном порядке и 
искать линейно, или в последовательном порядке или в виде само упорядочивающего списка по частоте для быстрого доступа.
В открытом адресном хэшировании, таблица перебирается в определенном порядке, начиная с занятого слота, обычно с помощью
линейного обхода, квадратичного, или двойного хэширования пока свободные слоты остаются или пока полная таблица не будет 
перебрана. Поиск элементов происходит по такой же процедуре пока элемент есть, открытые слоты есть или поиск происходит
по заполненной таблице. 

####Свойства хэш функций
Равномерность

Хорошая хэш функция должна отображать ожидаемые входные данные как можно более равномерно по всему выводящему диапазону. 
То есть, каждое хэш значение в выводе должно быть сгенерировано с одинаковой вероятностью.
Причина последнего требования в том, что стоимость методов, основывающихся на хэшировании, резко возрастает по мере 
увеличения числа пар-коллизий входных данных, которые сопоставляются с одним и тем же значением хеширования.
Если некоторые хэш значения встречаются чаще, чем остальные, большая часть операций поиска должна будет выполнять
поиск по большему набору сталкивающихся записей таблицы.  
Заметьте, что этот критерий только требует равномерного распределения значения, а не случайного. Хорошая функция 
рандомизации (за исключением проблем с вычислительной эффективностью) это обычно хороший выбор в качестве хэш функции, 
но обратное необязательно должно быть правдой.  
Хэш таблицы часто содержат только маленькие подмножества допустимых входных данных. Например, список клуба пользователей 
должен содержать только около сотни имен членов клуба из очень большого набора всех возможных имен. В данном случае, 
критерий однородности должен содержать почти все типичные подмножества ввода, которые могут быть найдены в таблице, 
не только для глобального набора всех возможных записей.  
В другом случае, если типичный набор из m записей будет хэширован в n слотов таблицы, сво
Другими словами, если типичный набор из m записей хэшируется в n слотов таблицы, вероятность того, что ведро получит 
намного больше, чем m/n записей, должна быть исчезающе мала. В частности, если m меньше n, очень немногие ведра должны 
иметь более одной или двух записей. Небольшое количество столкновений практически неизбежно, даже если n намного больше,
чем m 

В особых случаях, когда ключи известны заранее, а набор ключей статичен, можно найти хэш-функцию, 
которая обеспечивает абсолютную (или бесстолкновительную) однородность. Говорят, что такая хэш-функция идеальна.
Алгоритмического способа построения такой функции не существует - поиск одной из них является факториальной функцией 
количества ключей, которые должны быть сопоставлены, по сравнению с количеством слотов таблицы, в которые они 
сопоставлены. Поиск идеальной хэш-функции более чем по очень небольшому набору ключей обычно неосуществим с точки зрения
вычислений; результирующая функция, вероятно, будет более сложной в вычислительном отношении, чем стандартная 
хэш-функция, и обеспечивает лишь незначительное преимущество перед функцией с хорошими статистическими свойствами, 
которая дает минимальное количество коллизий. См.раздел Универсальная хэш-функция.
Испытания и измерения

При тестировании хэш-функции однородность распределения хэш-значений может быть оценена с помощью теста хи-квадрат. 
Этот тест является мерой соответствия: это фактическое распределение элементов в корзинах по сравнению с ожидаемым 
(или равномерным) распределением элементов. Формула такова: ∑ j = 0 m − 1 ( b j ) ( b j + 1 ) / 2 ( n / 2 m ) 
( n + 2 m − 1 ) {\displaystyle {\frac {\sum _{j=0}^{m-1}(b_{j})(b_{j}+1)/2}{(n/2m)(n+2m-1)}}} 
{\displaystyle {\frac {\sum _{j=0}^{m-1}(b_{j})(b_{j}+1)/2}{(n/2m)(n+2m-1)}}}

где: n {\displaystyle n} n - количество ключей, m {\displaystyle m} m - количество ведер, 
b j {\displaystyle b_{j}} b_{j} - количество элементов в ведре j {\displaystyle j} j

Отношение в пределах одного доверительного интервала (0,95 - 1,05) указывает на то, что оцениваемая хэш-функция 
имеет ожидаемое равномерное распределение.

Хэш-функции могут иметь некоторые технические свойства, которые повышают вероятность того, 
что они будут иметь равномерное распределение при применении. Одним из них является строгий критерий лавины: 
всякий раз, когда один входной бит дополняется, каждый из выходных битов изменяется с вероятностью 50%. 
Причина этого свойства заключается в том, что выбранные подмножества пространства ключей могут иметь низкую 
изменчивость. Для того чтобы выходные данные были равномерно распределены, низкая степень изменчивости, 
даже один бит, должна привести к высокой степени изменчивости (т. Е. распределению по табличному пространству) 
в выходных данных. Каждый бит должен изменяться с вероятностью 50%, потому что, если некоторые биты не хотят меняться, 
ключи группируются вокруг этих значений. Если биты хотят изменяться слишком легко, отображение приближается к 
фиксированной функции XOR одного бита. Стандартные тесты для этого свойства были описаны в литературе.[3] Здесь 
оценивается релевантность критерия мультипликативной хэш-функции.[4]



Эффективность

В приложениях для хранения и извлечения данных использование хэш-функции является компромиссом между временем 
поиска и пространством хранения данных. Если бы время поиска было неограниченным, лучшим носителем был бы очень 
компактный неупорядоченный линейный список; если бы пространство для хранения было неограниченным, случайно доступная 
структура, индексируемая значением ключа, была бы очень большой, очень разреженной, но очень быстрой. Хэш-функция 
занимает конечное количество времени, чтобы сопоставить потенциально большое пространство ключей с возможным объемом 
пространства для хранения, доступным для поиска за ограниченное количество времени, независимо от количества ключей. 
В большинстве приложений крайне желательно, чтобы хэш-функция была вычислимой с минимальной задержкой и, во-вторых, с 
минимальным количеством инструкций.

Вычислительная сложность зависит от количества требуемых инструкций и задержки отдельных инструкций, причем самыми 
простыми являются побитовые методы (свертка), за которыми следуют мультипликативные методы, а самыми сложными 
(самыми медленными) являются методы, основанные на делении.

Поскольку столкновения должны быть нечастыми и вызывать незначительную задержку, но в остальном безвредны,
обычно предпочтительнее выбрать более быструю хэш-функцию, а не ту, которая требует больше вычислений, но экономит 
несколько столкновений.

Реализации на основе разделения могут вызывать особую озабоченность, поскольку разделение микропрограммируется почти 
на всех архитектурах микросхем. Деление (по модулю) на константу может быть инвертировано, чтобы стать умножением на 
мультипликативный размер слова-обратный константе. Это может быть сделано программистом или компилятором. Деление 
также может быть сведено непосредственно к серии сдвигов-вычитаний и сдвигов-добавлений, хотя минимизация количества 
требуемых таких операций является сложной проблемой; количество инструкций по сборке в результате может составлять 
более дюжины, и трубопровод может затопить. Если архитектура имеет аппаратный функциональный блок умножения, то, 
скорее всего, лучшим подходом будет умножение на обратное.

Мы можем допустить, чтобы размер таблицы n не был равен степени 2, и все равно не нужно выполнять никаких операций 
остатка или деления, так как эти вычисления иногда являются дорогостоящими. Например, пусть n значительно меньше 2b.
Рассмотрим функцию генератора псевдослучайных чисел P(ключ), однородную на интервале [0, 2b − 1]. Хеш-функция, 
однородная на интервале [0, n-1], равна n P(ключ)/2b. Мы можем заменить деление на (возможно, более быстрый) 
сдвиг правого бита: nP(ключ) >> b.

Если ключи хэшируются неоднократно, а хэш-функция является дорогостоящей, вычислительное время можно сэкономить, 
предварительно вычислив хэш-коды и сохранив их вместе с ключами. Совпадающие хэш-коды почти наверняка означают, 
что ключи идентичны. Этот метод используется для таблицы транспозиции в игровых программах, в которой хранится 
64-битное хэшированное представление положения доски.


Универсальность
Основная статья: Универсальное хеширование

Универсальная схема хеширования-это рандомизированный алгоритм, который выбирает функцию хеширования h среди 
семейства таких функций таким образом, чтобы вероятность столкновения любых двух различных ключей составляла 1/m, 
где m—количество желаемых различных значений хеширования-независимо от двух ключей. Универсальное хеширование 
гарантирует (в вероятностном смысле), что приложение хэш-функции будет вести себя так же, как если бы оно использовало 
случайную функцию для любого распределения входных данных. Однако он будет иметь больше коллизий, чем идеальное 
хеширование, и может потребовать больше операций, чем специальная хэш-функция.
Применимость

Хэш-функция применима в самых разных ситуациях. Хэш-функция, которая допускает только определенные размеры таблиц, 
строки только до определенной длины или не может принять начальное значение (т. Е. Разрешить двойное хэширование), 
не так полезна, как та, которая это делает.
Детерминированный

Процедура хэширования должна быть детерминированной—это означает, что для заданного входного значения она всегда должна
генерировать одно и то же значение хэширования. Другими словами, это должна быть функция данных, подлежащих хэшированию,
в математическом смысле этого термина. Это требование исключает хэш-функции, которые зависят от параметров внешних 
переменных, таких как генераторы псевдослучайных чисел или время суток. Он также исключает функции, зависящие от адреса 
памяти хэшируемого объекта, в тех случаях, когда адрес может измениться во время выполнения (как это может произойти в
системах, использующих определенные методы сбора мусора), хотя иногда возможно повторное хэширование элемента.

Детерминизм находится в контексте повторного использования функции. Например, Python добавляет функцию, позволяющую
хэш-функциям использовать рандомизированное начальное значение, которое генерируется один раз при запуске процесса 
Python в дополнение к входным данным, подлежащим хэшированию.[5] Хэш Python (SipHash) по-прежнему является допустимой
хэш-функцией при использовании в течение одного запуска. Но если значения сохраняются (например, записываются на диск),
они больше не могут рассматриваться как допустимые хэш-значения, так как при следующем запуске случайное значение может
отличаться.
Определенный диапазон

Часто желательно, чтобы выходные данные хэш-функции имели фиксированный размер (но см. Ниже). Если, например, выходные 
данные ограничены 32-разрядными целочисленными значениями, хэш-значения можно использовать для индексирования в массив.
Такое хэширование обычно используется для ускорения поиска данных.[6] Получение выходных данных фиксированной длины из 
входных данных переменной длины может быть достигнуто путем разбиения входных данных на куски определенного размера. 
Хэш-функции, используемые для поиска данных, используют некоторое арифметическое выражение, которое итеративно 
обрабатывает фрагменты входных данных (например, символы в строке) для получения хэш-значения.[6]
Переменный диапазон

Во многих приложениях диапазон значений хэша может отличаться для каждого запуска программы или может изменяться в
течение одного и того же запуска (например, когда необходимо расширить хэш-таблицу). В таких ситуациях нужна 
хэш—функция, которая принимает два параметра-входные данные z и число n допустимых значений хэша.

Общее решение состоит в том, чтобы вычислить фиксированную хэш − функцию с очень большим диапазоном 
(скажем, от 0 до 232-1), разделить результат на n и использовать остаток от деления. Если n само по себе является 
степенью 2, это можно сделать путем маскировки битов и сдвига битов. При использовании этого подхода хэш − функция
должна быть выбрана таким образом, чтобы результат имел достаточно равномерное распределение между 0 и n-1 для любого 
значения n, которое может возникнуть в приложении. В зависимости от функции остаток может быть однородным только для 
определенных значений n, например, нечетных или простых чисел.
Переменный диапазон с минимальным движением (динамическая хэш-функция)

Когда хэш-функция используется для хранения значений в хэш-таблице, которая переживает запуск программы, и хэш-таблицу
необходимо расширить или уменьшить, хэш-таблица называется динамической хэш-таблицей.

Желательно использовать хэш-функцию, которая перемещает минимальное количество записей при изменении размера таблицы. 
Что необходимо,так это хэш – функция H(z, n), где z-хэшируемый ключ, а n-количество разрешенных хэш – значений, таких,
что H(z,n + 1) = H(z,n) с вероятностью, близкой к n/(n + 1).

Линейное хеширование и спиральное хранение являются примерами динамических хэш-функций, которые выполняются в постоянное 
время, но ослабляют свойство однородности для достижения свойства минимального перемещения.
Расширяемое хеширование использует динамическую хэш-функцию, для вычисления которой требуется пространство, 
пропорциональное n, и она становится функцией предыдущих вставленных ключей. Было изобретено несколько алгоритмов
,которые сохраняют свойство однородности, но требуют времени, пропорционального n, для вычисления значения H(z, n).
Хэш-функция с минимальным перемещением особенно полезна в распределенных хэш-таблицах.
  

Нормализация данных
В некоторых приложениях входные данные могут содержать функции, которые не имеют значения для целей сравнения.
Например, при поиске личного имени может быть желательно игнорировать различие между прописными и строчными буквами.
Для таких данных необходимо использовать хэш-функцию, совместимую с используемым критерием эквивалентности данных: 
то есть любые два входа, которые считаются эквивалентными, должны давать одно и то же хэш-значение. Это может быть 
достигнуто путем нормализации входных данных перед их хэшированием, например, путем ввода всех букв в верхнем регистре.


 





